/* --------------------------------------------------------------------------------
 #
 #  4DPlugin-COM4D.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : COM4D
 #	author : miyako
 #	2020/03/19
 #  
 # --------------------------------------------------------------------------------*/

#include "4DPlugin-COM4D.h"

#if VERSIONWIN

#define PROGID_COM4Dv3          L"COM4Dv3.Server"
#define DISPID_COM4Dv3_Call    1

HINSTANCE   g_hinstDLL = NULL;
LONG        g_nLockDLL = 0;
BOOL		g_isPlugin = FALSE;

#define GUID_COM4Dv3 L"23B91DD7-EB28-4EE6-809E526F7279516C"

//23B91DD7 EB28 4EE6 80 9E 52 6F 72 79 51 6C

const CLSID CLSID_COM4Dv3 =
{ 0x23B91DD7, 0xEB28, 0x4EE6,{ 0x80, 0x9E, 0x52, 0x6F, 0x72, 0x79, 0x51, 0x6C } };

#define AppID_COM4Dv3 CLSID_COM4Dv3

#define PAGE_MAXSIZE_LOW 0x1000000

class CCOM4Dv2Factory : public IClassFactory
{
public:

	CCOM4Dv2Factory();
	~CCOM4Dv2Factory();

	// IUnknown
	HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, LPVOID* ppv);
	ULONG STDMETHODCALLTYPE AddRef();
	ULONG STDMETHODCALLTYPE Release();
	// IClassFactory
	HRESULT STDMETHODCALLTYPE CreateInstance(IUnknown* pUnkOuter,
		REFIID riid, LPVOID* ppv);
	HRESULT STDMETHODCALLTYPE LockServer(BOOL fLock);

private:

	LONG    m_nRef;

};

class CCOM4Dv3 : public IDispatch
{
public:

	CCOM4Dv3();
	~CCOM4Dv3();

	// IUnknown
	HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, LPVOID* ppv);
	ULONG STDMETHODCALLTYPE AddRef();
	ULONG STDMETHODCALLTYPE Release();
	// IDispatch
	HRESULT STDMETHODCALLTYPE GetTypeInfoCount(UINT* pcTInfo);
	HRESULT STDMETHODCALLTYPE GetTypeInfo(UINT iTInfo, LCID lcid,
		ITypeInfo** ppTInfo);
	HRESULT STDMETHODCALLTYPE GetIDsOfNames(
		REFIID riidNull, LPOLESTR* rgszNames, UINT cNames,
		LCID lcid, DISPID* rgDispId);
	HRESULT STDMETHODCALLTYPE Invoke(
		DISPID dispIdMember, REFIID riidNull, LCID lcid,
		WORD wFlags, DISPPARAMS* pDispParams, VARIANT* pVarResult,
		EXCEPINFO* pExcepInfo, UINT* puArgErr);

private:

	HRESULT Write(DISPPARAMS* pDispParams, VARIANT* pVarResult);

private:

	LONG    m_nRef;
};

HANDLE hMap = NULL;

EXTERN_C BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD dwReason,
	LPVOID pvReserved)
{
	switch (dwReason) {
	case DLL_PROCESS_ATTACH:

		g_hinstDLL = hinstDLL;

		hMap = CreateFileMapping(
			INVALID_HANDLE_VALUE,
			NULL,
			PAGE_READWRITE,
			0, PAGE_MAXSIZE_LOW,
			GUID_COM4Dv3);

		break;
	case DLL_PROCESS_DETACH:

		if (hMap) {
			CloseHandle(hMap);
			hMap = NULL;
		}

		break;

	}

	return TRUE;
}

EXTERN_C HRESULT STDAPICALLTYPE DllInstall(BOOL bInstall,
	LPCWSTR pwszCmdline)
{
	const bool per_user_flag = suppIsPerUserRequest(pwszCmdline);
	try {
		HKEY    hkeyRoot;
		std::wstring    wstrSubkey;
		LONG    regerr;
		if (bInstall) {
			std::wstring    wstrName = suppGetModuleFileName(g_hinstDLL);
			std::wstring    wstrValue;
			// Coclass
			wstrSubkey = suppGetRegKeyCLSID(&hkeyRoot, per_user_flag, CLSID_COM4Dv3,
				L"InprocServer32");
			if (wstrSubkey.empty() || wstrName.empty()) {
				return E_FAIL;
			}
			regerr = suppRegSetStringW(hkeyRoot, wstrSubkey.c_str(), NULL,
				wstrName.c_str());
			if (regerr != ERROR_SUCCESS) {
				return SELFREG_E_CLASS;
			}
			// ProgID
			wstrSubkey = suppGetRegKeyCLSID(&hkeyRoot, per_user_flag, CLSID_COM4Dv3,
				L"ProgID");
			if (wstrSubkey.empty()) {
				return E_FAIL;
			}
			regerr = suppRegSetStringW(hkeyRoot, wstrSubkey.c_str(), NULL,
				PROGID_COM4Dv3);
			if (regerr != ERROR_SUCCESS) {
				return SELFREG_E_CLASS;
			}
			wstrSubkey = suppGetRegKeyProgID(&hkeyRoot, per_user_flag,
				PROGID_COM4Dv3, L"CLSID");
			wstrValue = suppGuidToString(CLSID_COM4Dv3, true);
			if (wstrSubkey.empty() || wstrValue.empty()) {
				return E_FAIL;
			}
			regerr = suppRegSetStringW(hkeyRoot, wstrSubkey.c_str(), NULL,
				wstrValue.c_str());
			if (regerr != ERROR_SUCCESS) {
				return SELFREG_E_CLASS;
			}
			// AppID
			wstrSubkey = suppGetRegKeyCLSID(&hkeyRoot, per_user_flag, CLSID_COM4Dv3,
				NULL);
			wstrValue = suppGuidToString(AppID_COM4Dv3, true);
			if (wstrSubkey.empty() || wstrValue.empty()) {
				return E_FAIL;
			}
			regerr = suppRegSetStringW(hkeyRoot, wstrSubkey.c_str(), L"AppID",
				wstrValue.c_str());
			if (regerr != ERROR_SUCCESS) {
				return SELFREG_E_CLASS;
			}
			wstrSubkey = suppGetRegKeyAppID(&hkeyRoot, per_user_flag, AppID_COM4Dv3,
				NULL);
			if (wstrSubkey.empty()) {
				return E_FAIL;
			}
			regerr = suppRegSetStringW(hkeyRoot, wstrSubkey.c_str(), L"DllSurrogate",
				L"");
			if (regerr != ERROR_SUCCESS) {
				return SELFREG_E_CLASS;
			}
		}
		else {
			wstrSubkey = suppGetRegKeyCLSID(&hkeyRoot, per_user_flag, CLSID_COM4Dv3,
				NULL);
			if (wstrSubkey.empty()) {
				return E_FAIL;
			}
			regerr = suppRegRemoveKeyW(hkeyRoot, wstrSubkey.c_str());
			if (regerr != ERROR_SUCCESS) {
				return SELFREG_E_CLASS;
			}
			wstrSubkey = suppGetRegKeyProgID(&hkeyRoot, per_user_flag,
				PROGID_COM4Dv3, NULL);
			if (wstrSubkey.empty()) {
				return E_FAIL;
			}
			regerr = suppRegRemoveKeyW(hkeyRoot, wstrSubkey.c_str());
			if (regerr != ERROR_SUCCESS) {
				return SELFREG_E_CLASS;
			}
			wstrSubkey = suppGetRegKeyAppID(&hkeyRoot, per_user_flag, AppID_COM4Dv3,
				NULL);
			if (wstrSubkey.empty()) {
				return E_FAIL;
			}
			regerr = suppRegRemoveKeyW(hkeyRoot, wstrSubkey.c_str());
			if (regerr != ERROR_SUCCESS) {
				return SELFREG_E_CLASS;
			}
		}
	}
	catch (const std::exception&) {
		return E_FAIL;
	}
	return S_OK;
}

EXTERN_C HRESULT STDAPICALLTYPE DllRegisterServer()
{
	return DllInstall(TRUE, NULL);
}

EXTERN_C HRESULT STDAPICALLTYPE DllUnregisterServer()
{
	return DllInstall(FALSE, NULL);
}

EXTERN_C HRESULT STDAPICALLTYPE DllCanUnloadNow()
{
	return  S_FALSE;

	//it's not wrong to stay loaded
	//return (g_nLockDLL <= 0) ? S_OK : S_FALSE;
}

EXTERN_C HRESULT STDAPICALLTYPE DllGetClassObject(REFCLSID rclsid,
	REFIID riid, LPVOID* ppv)
{
	static CCOM4Dv2Factory g_factory;
	*ppv = NULL;
	if (rclsid == CLSID_COM4Dv3) {
		return g_factory.QueryInterface(riid, ppv);
	}
	return CLASS_E_CLASSNOTAVAILABLE;
}

void print_debug_message() {
	DWORD error = GetLastError();
	wchar_t * lpMsgBuf = NULL;

	FormatMessage(
		FORMAT_MESSAGE_ALLOCATE_BUFFER |
		FORMAT_MESSAGE_FROM_SYSTEM |
		FORMAT_MESSAGE_IGNORE_INSERTS,
		NULL,
		error,
		MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
		(LPTSTR)&lpMsgBuf,
		0, NULL);
	OutputDebugStringW((const wchar_t *)lpMsgBuf);
}

BOOL takeNodeFromJsonFileMap(std::string *json) {

	BOOL success = FALSE;

	if (json) {

		if (hMap)
		{
			LPVOID buf = MapViewOfFile(hMap, FILE_MAP_READ, 0, 0, 0);

			if (buf) {

				unsigned char *p = (unsigned char *)buf;

				try
				{
					DWORD json_size = 0;
					CopyMemory(&json_size, p, sizeof(DWORD));
					p += sizeof(DWORD);

					std::vector<unsigned char>bytes(json_size);

					if (json_size) {

						CopyMemory(&bytes[0], p, json_size);
						*json = std::string((const char *)&bytes[0], json_size);

						success = TRUE;
					}

				}
				catch (...)
				{

				}
				UnmapViewOfFile(buf);

				if (success) {

					buf = MapViewOfFile(hMap, FILE_MAP_WRITE, 0, 0, 0);

					success = FALSE;

					if (buf)
					{
						try
						{
							unsigned char *p = (unsigned char *)buf;

							DWORD json_size = (DWORD)0L;

							CopyMemory(p, &json_size, sizeof(DWORD));

							success = TRUE;
						}
						catch (...)
						{

						}

						UnmapViewOfFile(buf);
					}
					else {
						print_debug_message();
					}
				}
			}
			else {
				print_debug_message();
			}
		}
		else {
			print_debug_message();
		}
	}

	return success;
}

BOOL addNodeToJsonFileMap(Json::Value node) {

	BOOL success = FALSE;

	if (node) {

		std::string json;

		if (hMap)
		{
			LPVOID buf = MapViewOfFile(hMap, FILE_MAP_READ, 0, 0, 0);

			if (buf)
			{
				unsigned char *p = (unsigned char *)buf;

				try
				{
					DWORD json_size = 0;
					CopyMemory(&json_size, p, sizeof(DWORD));
					p += sizeof(DWORD);

					std::vector<unsigned char>bytes(json_size);

					if (json_size) {

						CopyMemory(&bytes[0], p, json_size);
						json = std::string((const char *)&bytes[0], json_size);

						success = TRUE;
					}

				}
				catch (...)
				{

				}

				UnmapViewOfFile(buf);
			}
			else {
				print_debug_message();
			}

			bool parse = false;
			Json::Value root;

			if (success) {

				Json::CharReaderBuilder builder;
				std::string errors;

				Json::CharReader *reader = builder.newCharReader();
				parse = reader->parse(json.c_str(),
					json.c_str() + json.size(),
					&root,
					&errors);
				delete reader;

				success = FALSE;
			}

			if ((!parse) || !root.isArray())
			{
				root = Json::Value(Json::arrayValue);
			}

			Json::ArrayIndex i = root.size();
			i++;
			root[i] = node;

			Json::StreamWriterBuilder builder;
			json = Json::writeString(builder, root);

			buf = MapViewOfFile(hMap, FILE_MAP_WRITE, 0, 0, 0);

			if (buf)
			{
				try
				{
					unsigned char *p = (unsigned char *)buf;

					DWORD json_size = (DWORD)json.size();

					CopyMemory(p, &json_size, sizeof(DWORD));
					p += sizeof(DWORD);
					CopyMemory(p, json.c_str(), json_size);

					success = TRUE;
				}
				catch (...)
				{

				}

				UnmapViewOfFile(buf);
			}
			else {
				print_debug_message();
			}
		}
	}

	return success;
}

//because class oject is static, we should not delete it
//https://ichigopack.net/win32com/com_base_5.html

CCOM4Dv2Factory::CCOM4Dv2Factory() : m_nRef(0)
{
	if (g_isPlugin) {
		
	}
}

CCOM4Dv2Factory::~CCOM4Dv2Factory()
{
	if (g_isPlugin) {

	}
}

HRESULT STDMETHODCALLTYPE CCOM4Dv2Factory::QueryInterface(REFIID riid,
	LPVOID* ppv)
{
	*ppv = NULL;
	if (riid == IID_IUnknown || riid == IID_IClassFactory) {
		*ppv = static_cast<IClassFactory*>(this);
		AddRef();
		return S_OK;
	}
	return E_NOINTERFACE;
}

ULONG STDMETHODCALLTYPE CCOM4Dv2Factory::AddRef()
{
	if (m_nRef++ == 0) {
		++g_nLockDLL;
	}
	return m_nRef;
}

ULONG STDMETHODCALLTYPE CCOM4Dv2Factory::Release()
{
	if (--m_nRef == 0) {
		--g_nLockDLL;
	}
	return m_nRef;
}

HRESULT STDMETHODCALLTYPE CCOM4Dv2Factory::CreateInstance(
	IUnknown* pUnkOuter, REFIID riid, LPVOID* ppv)
{
	*ppv = NULL;
	if (pUnkOuter != NULL) {
		return CLASS_E_NOAGGREGATION;
	}
	CCOM4Dv3* pObj = new (std::nothrow) CCOM4Dv3();
	if (pObj == NULL) {
		return E_OUTOFMEMORY;
	}
	HRESULT hr = pObj->QueryInterface(riid, ppv);
	pObj->Release();
	return hr;
}

HRESULT STDMETHODCALLTYPE CCOM4Dv2Factory::LockServer(BOOL fLock)
{
	if (fLock) {
		++g_nLockDLL;
	}
	else {
		--g_nLockDLL;
	}
	return S_OK;
}

CCOM4Dv3::CCOM4Dv3() : m_nRef(1)
{
	++g_nLockDLL;
}

CCOM4Dv3::~CCOM4Dv3()
{
	--g_nLockDLL;
}

HRESULT STDMETHODCALLTYPE CCOM4Dv3::QueryInterface(REFIID riid,
	LPVOID* ppv)
{
	*ppv = NULL;
	if (riid == IID_IUnknown || riid == IID_IDispatch) {
		*ppv = static_cast<IDispatch*>(this);
		AddRef();
		return S_OK;
	}
	return E_NOINTERFACE;
}

ULONG STDMETHODCALLTYPE CCOM4Dv3::AddRef()
{
	return ++m_nRef;
}

ULONG STDMETHODCALLTYPE CCOM4Dv3::Release()
{
	if (--m_nRef == 0) {
		delete this;
		return 0;
	}
	return m_nRef;
}

HRESULT STDMETHODCALLTYPE CCOM4Dv3::GetTypeInfoCount(UINT* pcTInfo)
{
	*pcTInfo = 0;
	return S_OK;
}

HRESULT STDMETHODCALLTYPE CCOM4Dv3::GetTypeInfo(UINT iTInfo, LCID lcid,
	ITypeInfo** ppTInfo)
{
	return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE CCOM4Dv3::GetIDsOfNames(
	REFIID riidNull, LPOLESTR* rgszNames, UINT cNames,
	LCID lcid, DISPID* rgDispId)
{
	UINT    iName;
	HRESULT hr = S_OK;
	if (riidNull != IID_NULL) {
		return DISP_E_UNKNOWNINTERFACE;
	}
	for (iName = 0; iName < cNames; ++iName) {
		DISPID  id = DISPID_UNKNOWN;
		if (lstrcmpW(rgszNames[iName], L"Call") == 0) {
			id = DISPID_COM4Dv3_Call;
		}

		rgDispId[iName] = id;
		if (id == DISPID_UNKNOWN) {
			hr = DISP_E_UNKNOWNNAME;
		}
	}
	return hr;
}

HRESULT STDMETHODCALLTYPE CCOM4Dv3::Invoke(
	DISPID dispIdMember, REFIID riidNull, LCID lcid,
	WORD wFlags, DISPPARAMS* pDispParams, VARIANT* pVarResult,
	EXCEPINFO* pExcepInfo, UINT* puArgErr)
{
	UINT    uArgErrTemp;
	if (puArgErr == NULL) {
		puArgErr = &uArgErrTemp;
	}
	if (riidNull != IID_NULL) {
		return DISP_E_UNKNOWNINTERFACE;
	}

	HRESULT hr;

	/* DISPID_COM4Dv3_Write */
	if ((wFlags & DISPATCH_METHOD) != 0 &&
		dispIdMember == DISPID_COM4Dv3_Call) {
		if (pDispParams->cArgs == 0) {
			return DISP_E_BADPARAMCOUNT;
		}

		hr = Write(pDispParams, pVarResult);

	}

	else {
		return DISP_E_MEMBERNOTFOUND;
	}
	if (FAILED(hr)) {
		if (pExcepInfo != NULL) {
			pExcepInfo->scode = hr;
			pExcepInfo->wCode = 0;
			pExcepInfo->wReserved = 0;
			pExcepInfo->bstrSource = NULL;
			pExcepInfo->bstrDescription = NULL;
			pExcepInfo->bstrHelpFile = NULL;
			pExcepInfo->dwHelpContext = 0;
			pExcepInfo->pvReserved = NULL;
			pExcepInfo->pfnDeferredFillIn = NULL;
		}
		IErrorInfo* pei = NULL;
		if (S_OK == GetErrorInfo(0, &pei)) {
			if (pExcepInfo != NULL) {
				if (FAILED(pei->GetSource(&pExcepInfo->bstrSource)))
					pExcepInfo->bstrSource = NULL;
				if (FAILED(pei->GetDescription(&pExcepInfo->bstrDescription)))
					pExcepInfo->bstrDescription = NULL;
				if (FAILED(pei->GetHelpFile(&pExcepInfo->bstrHelpFile)))
					pExcepInfo->bstrHelpFile = NULL;
				if (FAILED(pei->GetHelpContext(&pExcepInfo->dwHelpContext)))
					pExcepInfo->dwHelpContext = 0;
			}
			pei->Release();
		}
		if (pExcepInfo != NULL && pExcepInfo->bstrSource == NULL)
			pExcepInfo->bstrSource = SysAllocString(PROGID_COM4Dv3);
		return DISP_E_EXCEPTION;
	}

	return hr;
}

void conv(BSTR bstr, std::string& str) {

	if (bstr) {
		int count = SysStringLen(bstr);
		int len = WideCharToMultiByte(CP_UTF8, 0, (LPCWSTR)bstr, count, NULL, 0, NULL, NULL);
		if (len) {
			std::vector<uint8_t> buf(len + 1);
			if (WideCharToMultiByte(CP_UTF8, 0, (LPCWSTR)bstr, count, (LPSTR)&buf[0], len, NULL, NULL)) {
				str = std::string((const char *)&buf[0]);
				return;
			}
		}
	}
	str = "";
}

HRESULT CCOM4Dv3::Write(DISPPARAMS* pDispParams, VARIANT* pVarResult)
{
	try {
		//build json string representation of pDispParams

		Json::Value root = Json::Value(Json::arrayValue);

		for (Json::ArrayIndex i = 0; i < pDispParams->cArgs; ++i) {
		
			VARTYPE type = pDispParams->rgvarg[i].vt;

			switch (type)
			{
			case VT_EMPTY:
			{
				Json::Value param;
				param["type"] = "VT_EMPTY";
				param["value"] = Json::Value(Json::nullValue);

				root[i] = param;
			}
			break;

			case VT_NULL:
			{
				Json::Value param;
				param["type"] = "VT_NULL";
				param["value"] = Json::Value(Json::nullValue);

				root[i] = param;
			}
			break;

			case VT_BSTR:
			{
				Json::Value param;
				param["type"] = "VT_BSTR";
				std::string value;
				conv(pDispParams->rgvarg[i].bstrVal, value);
				param["value"] = value;

				root[i] = param;
			}
			break;

			case VT_BOOL:
			{
				Json::Value param;
				param["type"] = "VT_BOOL";
				param["value"] = pDispParams->rgvarg[i].boolVal;

				root[i] = param;
			}
			break;

			case VT_UI1:
			{
				Json::Value param;
				param["type"] = "VT_UI1";
				param["value"] = pDispParams->rgvarg[i].bVal;

				root[i] = param;
			}
			break;

			case VT_I1:
			{
				Json::Value param;
				param["type"] = "VT_I1";
				param["value"] = pDispParams->rgvarg[i].cVal;

				root[i] = param;
			}
			break;

			case VT_UI2:
			{
				Json::Value param;
				param["type"] = "VT_UI2";
				param["value"] = pDispParams->rgvarg[i].uiVal;

				root[i] = param;
			}
			break;

			case VT_I2:
			{
				Json::Value param;
				param["type"] = "VT_I2";
				param["value"] = pDispParams->rgvarg[i].iVal;

				root[i] = param;
			}
			break;

			case VT_I4:
			{
				Json::Value param;
				param["type"] = "VT_I4";
				param["value"] = pDispParams->rgvarg[i].lVal;

				root[i] = param;
			}
			break;

			case VT_UINT:
			{
				Json::Value param;
				param["type"] = "VT_UINT";
				param["value"] = pDispParams->rgvarg[i].uintVal;

				root[i] = param;
			}
			break;

			case VT_INT:
			{
				Json::Value param;
				param["type"] = "VT_INT";
				param["value"] = pDispParams->rgvarg[i].intVal;

				root[i] = param;
			}
			break;

			case VT_R4:
			{
				Json::Value param;
				param["type"] = "VT_R4";
				param["value"] = pDispParams->rgvarg[i].fltVal;

				root[i] = param;
			}
			break;

			case VT_R8:
			{
				Json::Value param;
				param["type"] = "VT_R8";
				param["value"] = pDispParams->rgvarg[i].dblVal;

				root[i] = param;
			}
			break;

			case VT_ERROR:
			{
				Json::Value param;
				param["type"] = "VT_ERROR";
				param["value"] = pDispParams->rgvarg[i].scode;

				root[i] = param;
			}
			break;

			case VT_DATE:
			{
				Json::Value param;
				param["type"] = "VT_DATE";

				SYSTEMTIME systemTime;
				if (VariantTimeToSystemTime(pDispParams->rgvarg[i].date, &systemTime)) {

					std::ostringstream formatted_date_time;
					formatted_date_time << std::setfill('0');

					formatted_date_time << systemTime.wYear << "-" <<
						std::setw(2) << systemTime.wMonth << "-" <<
						std::setw(2) << systemTime.wDay << "T" <<
						std::setw(2) << systemTime.wHour << ":" <<
						std::setw(2) << systemTime.wMinute << ":" <<
						std::setw(2) << systemTime.wSecond << "Z";

					std::string value = formatted_date_time.str();
					param["value"] = value.c_str();

					root[i] = param;
				}

			}
			break;

			case VT_CY:
			case VT_UI4:
			case VT_DECIMAL:
				break;

			default:
				break;
			}
		}

		if (addNodeToJsonFileMap(root)) {

			if (pVarResult->vt == VT_BSTR) {
				std::wstring json;
				Json::StreamWriterBuilder builder;
				std::string str = Json::writeString(builder, root);
				int len = MultiByteToWideChar(CP_UTF8, 0, (LPCSTR)str.c_str(), str.length(), NULL, 0);

				if (len) {
					std::vector<uint8_t> buf((len + 1) * sizeof(wchar_t));
					if (MultiByteToWideChar(CP_UTF8, 0, (LPCSTR)str.c_str(), str.length(), (LPWSTR)&buf[0], len)) {
						json = std::wstring((const wchar_t *)&buf[0]);
					}
				}
				//https://docs.microsoft.com/en-us/cpp/atl-mfc-shared/allocating-and-releasing-memory-for-a-bstr?view=vs-2019
				pVarResult->bstrVal = SysAllocString(json.c_str());
			}

			return S_OK;
		}
		else {

			ICreateErrorInfo* pcreateei = NULL;
			IErrorInfo* pei = NULL;
			HRESULT hr;

			hr = CreateErrorInfo(&pcreateei);
			if (SUCCEEDED(hr)) {
				pcreateei->SetSource(PROGID_COM4Dv3);
				pcreateei->SetDescription(L"could not add json data to internal file map!");
				hr = pcreateei->QueryInterface(IID_IErrorInfo, (LPVOID*)&pei);
				if (SUCCEEDED(hr)) {
					SetErrorInfo(0, pei);
					pei->Release();
				}
				pcreateei->Release();
			}

			return E_ABORT;
		}
		
	}
	catch (const std::exception&) {
		return E_FAIL;
	}
}

#endif

void PluginMain(PA_long32 selector, PA_PluginParameters params) {
    
	try
	{
        switch(selector)
        {
		case kInitPlugin:
		case kServerInitPlugin:
#if VERSIONWIN
                g_isPlugin = TRUE;
#endif
			break;
			// --- COM4D
            
			case 1 :
				COM_Setup(params);
				break;
			case 2:
				COM_Write(params);
				break;
			case 3:
				COM_Read(params);
				break;
        }

	}
	catch(...)
	{

	}
}

#if VERSIONWIN

HRESULT Invoke(IDispatch *pDispatch, LPOLESTR lpszName, WORD wFlags, VARIANT *pVarArray, int nArgs, VARIANT *pVarResult, EXCEPINFO* pExcepInfo)
{
	DISPPARAMS dispParams;
	DISPID     dispid;
	DISPID     dispidName = DISPID_PROPERTYPUT;
	HRESULT    hr;

	hr = pDispatch->GetIDsOfNames(IID_NULL, &lpszName, 1, LOCALE_USER_DEFAULT, &dispid);
	if (FAILED(hr))
		return hr;

	dispParams.cArgs = nArgs;
	dispParams.rgvarg = pVarArray;
	if (wFlags & DISPATCH_PROPERTYPUT) {
		dispParams.cNamedArgs = 1;
		dispParams.rgdispidNamedArgs = &dispidName;
	}
	else {
		dispParams.cNamedArgs = 0;
		dispParams.rgdispidNamedArgs = NULL;
	}

	hr = pDispatch->Invoke(dispid, IID_NULL, LOCALE_SYSTEM_DEFAULT, wFlags, &dispParams, pVarResult, pExcepInfo, NULL);

	return hr;
}

void ob_Set_error(PA_ObjectRef status) {

	if(status) {

		DWORD err = GetLastError();

		ob_set_n(status, L"code", err);

		wchar_t * lpMsgBuf = NULL;

		FormatMessage(
			FORMAT_MESSAGE_ALLOCATE_BUFFER |
			FORMAT_MESSAGE_FROM_SYSTEM |
			FORMAT_MESSAGE_IGNORE_INSERTS,
			NULL,
			err,
			MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
			(LPTSTR)&lpMsgBuf,
			0, NULL);

		ob_set_a(status, L"errorMessage", (const wchar_t *)lpMsgBuf);

		LocalFree(lpMsgBuf);
	}
}

void regsvr32(PA_ObjectRef status, const wchar_t *lpParameters) {

	if (status) {
		if (lpParameters) {
			SHELLEXECUTEINFO ShExecInfo;
			ZeroMemory(&ShExecInfo, sizeof(ShExecInfo));

			HMODULE hplugin = GetModuleHandleW(L"COM4D.4DX");
			wchar_t	thisPath[_MAX_PATH] = { 0 };
			wchar_t	fDrive[_MAX_DRIVE], fDir[_MAX_DIR], fName[_MAX_FNAME], fExt[_MAX_EXT];
			if (GetModuleFileNameW(hplugin, thisPath, _MAX_PATH)) {
				_wsplitpath_s(thisPath, fDrive, fDir, fName, fExt);
				std::wstring path = fDrive;
				path += fDir;//path to plugin parent folder
				ShExecInfo.cbSize = sizeof(SHELLEXECUTEINFO);
				ShExecInfo.fMask = SEE_MASK_FLAG_NO_UI;
				ShExecInfo.hwnd = NULL;
				ShExecInfo.lpVerb = NULL;
				ShExecInfo.lpFile = L"REGSVR32.EXE";
				ShExecInfo.lpParameters = lpParameters;
				ShExecInfo.lpDirectory = path.c_str();
				ShExecInfo.nShow = SW_HIDE;
				ShExecInfo.hInstApp = NULL;

				if (ShellExecuteEx(&ShExecInfo)) {

				}
				else {

					ob_Set_error(status);

				}
			}
		}
	}
}

BOOL is_dll_registered() {

	BOOL is_registered = 0;

	 HRESULT hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED | COINIT_DISABLE_OLE1DDE);

	if (SUCCEEDED(hr)) {

		wchar_t *progid = (wchar_t *)PROGID_COM4Dv3;

		CLSID CLSID_test;
		hr = CLSIDFromProgID(progid, &CLSID_test);

		is_registered = SUCCEEDED(hr);

		CoUninitialize();
	}

	return is_registered;
}

void get_dll_status(PA_ObjectRef status){

	if (status) {
		ob_set_a(status, L"clsid", GUID_COM4Dv3);
		ob_set_a(status, L"progid", PROGID_COM4Dv3);
		ob_set_b(status, L"isRegistered", is_dll_registered());
	}
}

void register_dll(PA_ObjectRef status, BOOL to_register = TRUE) {

	if (status) {

		if (to_register) {
			regsvr32(status, L"/s /i:user /n COM4D.4DX");/* silent install */
		}
		else {
			regsvr32(status, L"/s /i:user /u COM4D.4DX");/* silent uninstall */
		}

		ob_set_a(status, L"clsid", GUID_COM4Dv3);
		ob_set_a(status, L"progid", PROGID_COM4Dv3);
	}
}

void COM_Setup(PA_PluginParameters params) {
	
	PA_ObjectRef status = PA_CreateObject();

	com_setup_t setup = (com_setup_t)PA_GetLongParameter(params, 1);

	switch (setup)
	{
	case com_setup_register:
		register_dll(status);
		break;
	case com_setup_unregister:
		register_dll(status, FALSE);
		break;
	default:
		get_dll_status(status);
		break;
	}

	PA_ReturnObject(params, status);
}

void COM_Read(PA_PluginParameters params) {

	PA_ObjectRef status = PA_CreateObject();

	std::string json;

	BOOL success = takeNodeFromJsonFileMap(&json);

	ob_set_b(status, L"success", success);

	if (success) {

		Json::CharReaderBuilder builder;
		std::string errors;
		Json::Value root;

		Json::CharReader *reader = builder.newCharReader();
		bool parse = reader->parse(json.c_str(),
			json.c_str() + json.size(),
			&root,
			&errors);
		delete reader;

		PA_CollectionRef array_of_values = PA_CreateCollection();

		if (parse) {
			if (root.isArray()) {

				for (Json::ValueIterator i = root.begin(); i != root.end(); ++i)
				{
					PA_CollectionRef values = PA_CreateCollection();

					Json::Value node = *i;

					if (!node.isNull()) {
						if (node.isArray()) {
							for (Json::ValueIterator ii = node.begin(); ii != node.end(); ++ii)
							{
								Json::Value _value = *ii;

								PA_ObjectRef value = PA_CreateObject();

								Json::Value _type = _value["type"];

								bool is_value_valid = false;

								if ((_type) && _type.isString()) {

									std::string type = _type.asString();

									if ((type == "VT_BSTR") || (type == "VT_DATE")) {
										Json::Value __value = _value["value"];
										if ((__value) && __value.isString()) {
											std::string ___value = __value.asString();
											ob_set_s(value, type.c_str(), ___value.c_str());
											is_value_valid = true;
										}
									}
									else

										if ((type == "VT_EMPTY") || (type == "VT_NULL")) {

											ob_set_0(value, type.c_str());
											is_value_valid = true;
										}
										else

											if (type == "VT_BOOL") {
												Json::Value __value = _value["value"];
												if ((__value) && __value.isBool()) {
													bool ___value = __value.asBool();
													ob_set_b(value, type.c_str(), ___value);
													is_value_valid = true;
												}
											}
											else

												if ((type == "VT_UI1") || (type == "VT_UI2") || (type == "VT_UINT")) {
													Json::Value __value = _value["value"];
													if ((__value) && __value.isNumeric()) {
														Json::UInt ___value = __value.asUInt();
														ob_set_n(value, type.c_str(), ___value);
														is_value_valid = true;
													}
												}
												else

													if ((type == "VT_I1") || (type == "VT_I2") || (type == "VT_I4") || (type == "VT_INT") || (type == "VT_ERROR")) {
														Json::Value __value = _value["value"];
														if ((__value) && __value.isNumeric()) {
															Json::Int ___value = __value.asInt();
															ob_set_n(value, type.c_str(), ___value);
															is_value_valid = true;
														}
													}
													else

														if ((type == "VT_R4") || (type == "VT_R8")) {
															Json::Value __value = _value["value"];
															if ((__value) && __value.isNumeric()) {
																double ___value = __value.asDouble();
																ob_set_n(value, type.c_str(), ___value);
																is_value_valid = true;
															}
														}
								}

								PA_Variable v;
								if (is_value_valid) {
									v = PA_CreateVariable(eVK_Object);
									PA_SetObjectVariable(&v, value);
								}
								else {
									v = PA_CreateVariable(eVK_Null);
								}

								PA_SetCollectionElement(values, PA_GetCollectionLength(values), v);
								PA_ClearVariable(&v);

							}
						}

						PA_Variable v = PA_CreateVariable(eVK_Collection);
						PA_SetCollectionVariable(&v, values);
						PA_SetCollectionElement(array_of_values, PA_GetCollectionLength(array_of_values), v);
						PA_ClearVariable(&v);
					}
				}
			}
		}

		ob_set_c(status, L"values", array_of_values);
	}

	PA_ReturnObject(params, status);
}

void COM_Write(PA_PluginParameters params) {

	PA_ObjectRef status = PA_CreateObject();
	PA_CollectionRef values = PA_GetCollectionParameter(params, 1);

	BOOL success = FALSE;

	if (values) {

		IDispatch *pDispatch;

		HRESULT hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);

		if (SUCCEEDED(hr)) {

			wchar_t *progid = (wchar_t *)PROGID_COM4Dv3;

			CLSID CLSID_test;
			hr = CLSIDFromProgID(progid, &CLSID_test);

			if (SUCCEEDED(hr)) {

				hr = CoCreateInstance(CLSID_test, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARGS(&pDispatch));
				if (SUCCEEDED(hr)) {

					PA_long32 len = PA_GetCollectionLength(values);
					std::vector<VARIANT>args(len);
					VARIANT   varResult;
					std::vector<BSTR>strs;

					for (PA_long32 i = 0; i < len; ++i) {

						PA_Variable v = PA_GetCollectionElement(values, i);

						PA_VariableKind kind = PA_GetVariableKind(v);
						BSTR str;
						PA_Unistring u;
						short dd, mm, yyyy;
						SYSTEMTIME time;

						VariantInit(&args[i]);

						args[i].vt = VT_EMPTY;

						switch (kind)
						{
						case eVK_Null:
						case -1:
							args[i].vt = VT_NULL;
							break;
						case eVK_Unistring:
						case eVK_Text:
							args[i].vt = VT_BSTR;
							u = PA_GetStringVariable(v);
							str = SysAllocString((const OLECHAR *)PA_GetUnistring(&u));
							strs.push_back(str);
							args[i].bstrVal = str;
							break;
						case eVK_Boolean:
							args[i].vt = VT_BOOL;
							args[i].boolVal = static_cast<VARIANT_BOOL>(PA_GetBooleanVariable(v));
							break;
						case eVK_Date:
							PA_GetDateVariable(v, &dd, &mm, &yyyy);
							args[i].vt = VT_DATE;
							ZeroMemory(&time, sizeof(time));
							time.wYear = static_cast<DWORD>(yyyy);
							time.wMonth = static_cast<DWORD>(mm);
							time.wDay = static_cast<DWORD>(dd);
							SystemTimeToVariantTime(&time, &args[i].date);
							break;
						case eVK_Integer:
						case eVK_Longint:
							args[i].vt = VT_I4;
							args[i].lVal = static_cast<LONG>(PA_GetLongintVariable(v));
							break;
						case eVK_Real:
							args[i].vt = VT_R8;
							args[i].dblVal = static_cast<DOUBLE>(PA_GetRealVariable(v));
							break;
						case eVK_Time:
							args[i].vt = VT_I4;
							args[i].lVal = static_cast<LONG>(PA_GetTimeVariable(v));
							break;
						default:
							break;
						}

					}

					VariantInit(&varResult);
					varResult.vt = VT_BSTR; /* receive json */

					EXCEPINFO excepInfo = { 0 };
					hr = Invoke(pDispatch, L"Call", DISPATCH_METHOD, &args[0], len, &varResult, &excepInfo);

					if (hr == S_OK) {
						success = TRUE;
						ob_set_a(status, L"data", varResult.bstrVal);
						SysFreeString(varResult.bstrVal);
					}

					for (std::vector<BSTR>::iterator it = strs.begin(); it != strs.end(); ++it) {
						BSTR str = *it;
						SysFreeString(str);
					}

					for (std::vector<VARIANT>::iterator it = args.begin(); it != args.end(); ++it) {
						VARIANT arg = *it;
						VariantClear(&arg);
					}

					VariantClear(&varResult);

					pDispatch->Release();
				}

			}
			CoUninitialize();
		}

	}
		
	ob_set_b(status, L"success", success);
	PA_ReturnObject(params, status);
}

#else
void returnEmptyObject(PA_PluginParameters params) {PA_ReturnObject(params, PA_CreateObject());}
void COM_Setup(PA_PluginParameters params) {returnEmptyObject(params);}
void COM_Write(PA_PluginParameters params) {returnEmptyObject(params);}
void COM_Read (PA_PluginParameters params) {returnEmptyObject(params);}
#endif
